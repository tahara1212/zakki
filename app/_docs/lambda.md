---
title: "Lambda パフォーマンス最適化"
---

## コールドスタートとレイテンシー

Lambda サービスが Lambda API を介して関数を実行するリクエストを受け取ると、サービスは最初に実行環境を準備する。この時、サービスは内部の S3 に保存されている関数のコードをダウンロードする。次に、指定されたメモリ、ランタイム、各種設定に基づいた環境を作成する。

これらが完了すると、Lambda はイベントハンドラー外に記述された初期化コードを実行する。イベントハンドラー外に記述された初期化コードとは、具体的には、関数が起動される前に一度だけ実行されるコードが含まる。例えば、外部ライブラリのインポート、データベース接続の確立、グローバル変数の初期化などが該当する。

これらを実行した後、最終的にハンドラーコードを実行する。

![Performance 1.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/4fc61ac9-b4cf-4a6f-b4b2-c624a50e6c56/35836097-015a-4a22-843a-51760677c9ae/Performance_1.png)

この図における、環境とコードをセットアップする最初の 2 つのステップは「コールドスタート」と呼ばれる。ハンドラーコードの実行が完了すると、環境はフリーズされ、Lambda は実行環境を不特定期間保持する。この間、同じ関数に対するリクエストが行われた場合、環境を再利用するよう試みる。このような二番目のリクエストは、実行環境がすでに存在し、コードをダウンロードして初期化コードを実行する必要がないため迅速に終了する。これを「ウォームスタート」と呼ぶ。

## **実行環境のライフサイクル**

Lambda は、実行後しばらくは環境を保持し続ける。環境の存続期間は様々な要因の影響を受け、開発者が設定することはできない。実行環境の再利用は有用なものの、パフォーマンスの最適化をこれに依存すべきではない。Lambda は AWS リージョン内の複数の Availability Zones（データセンターの配置）に跨って実行を管理する。そのため、短時間に関数が２回呼び出されたとしても、この負荷分散の挙動によりいずれの実行においてもコールドスタートが発生する可能性がある。

そして、トラフィックの増加によって Lambda 関数がスケールアップされる際には、関数の追加の呼び出しごとに、新たな実行環境が必要となる。この新たな実行環境においては、コールドスタートが発生することを意味している。

Lambda 関数の更新や設定を変更した場合、次の呼び出しにおいてはコールドスタートが発生する。

![performance2.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/4fc61ac9-b4cf-4a6f-b4b2-c624a50e6c56/a807a8c9-9fb2-40a4-8a09-758a3ae90d83/performance2.png)

## **関数ウォーマーの仕組みを理解する**

サーバーレスのコミュニティでは、ping メカニズムを介して Lambda 関数を「ウォーム」するためのオープンソースライブラリが提供されている。 EventBridge ルール を使用して 1 分ごとに関数の呼び出しをスケジュールすることで、実行環境をアクティブに保ち、関数を呼び出す際にウォーム環境が使用される可能性を高めるアプローチである。

しかし、トラフィックの増加によるスケールアップや、 Lambda の負荷分散の影響に対応しきれないため、これらは効果を発揮しない可能性が高い。また、 Lambda は実行環境を最新に保つために定期的に環境を破棄するため、ping の隙間に関数が呼び出される可能性がある。

## **Provisioned Concurrency によるコールドスタートの削減**

Provisioned Concurrency は Lambda の機能で、特定の数の実行環境を常にウォームな状態に保つことを保証する。これにより、コールドスタートの問題を効果的に解決できる。

この機能により、関数は初期化およびウォームアップされ、プロビジョニングしたスケールで 2 桁のミリ秒で応答できる準備が整う。これは、オンデマンドの Lambda 関数とは異なり、初期化コードの実行を含め、すべてのセットアップアクティビティが呼び出しの前に行われることを意味している。

![performance3.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/4fc61ac9-b4cf-4a6f-b4b2-c624a50e6c56/79894584-0d28-4301-a691-16d78b5ade47/performance3.png)

たとえば、Provisioned Concurrency が 6 の関数では、実際の呼び出しが発生する前から 6 つの実行環境が準備される。実行環境の準備は初期化から呼び出しまでの間に完了する。

![Performance 4.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/4fc61ac9-b4cf-4a6f-b4b2-c624a50e6c56/5b9febde-4ad2-4509-a5f3-9e16007f162f/Performance_4.png)

Provisioned Concurrency は、プロビジョニングされたコンカレンシーの数に応じて、1ミリ秒ごとの料金が発生する。これは、プロビジョニングされたすべてのインスタンスがウォームな状態で待機している時間に対して課金される。また、通常のLambda関数と同様に、リクエストごとに課金されます。また、関数が実行されている時間（ミリ秒単位）に対しても課金が発生する。

## **呼び出しパターンを理解する**

 Lambda の実行環境は、一度に１つずつリクエストを処理する。呼び出しの終了後、環境は一定期間保持されるので、ここで別のリクエストが到着した場合、環境は再利用される。

リクエストが同時に到着した場合、 Lambda は複数の実行環境を提供するために関数をスケールアウトする。各環境は個別にセットアップされ、各呼び出しでコールドスタートが発生する。

Amazon API Gateway が Lambda 関数を同時に呼び出した場合、Lambda は 6 つの実行環境を作成する。各呼び出しの実行時間には、コールドスタートが含まれる。

![performance5.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/4fc61ac9-b4cf-4a6f-b4b2-c624a50e6c56/248382e6-56bb-41e9-980f-0ef2b72751a9/performance5.png)

しかし、 API Gateway が Lambda 関数を 6 回連続して呼び出す際に、各呼び出しの間に遅延がある場合、以前の呼び出しが完了していれば既存の実行環境が再利用されることになる。以下の例では、最初の 2 つの呼び出しでのみコールドスタートが発生し、3 ～ 6 の呼び出しではウォーム環境が使用される。

![Performance 6.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/4fc61ac9-b4cf-4a6f-b4b2-c624a50e6c56/938f4311-b5d4-4820-8dc7-12b09dfac558/Performance_6.png)

非同期呼び出しの場合、呼び出し側と Lambda サービスの間に内部キューが存在する。Lambda は必要に応じて自動的にスケールアップしつつ、このキューからのメッセージをできるだけ早く処理する。関数に Reserved Concurrency が指定されている場合、これは関数単位の同時実行数の上限として機能する。

たとえば S3 バケットに対して、オブジェクトがバケットに書き込まれた際に Lambda 関数を呼び出すよう設定されていたする。

![performance7.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/4fc61ac9-b4cf-4a6f-b4b2-c624a50e6c56/38b0bde0-ec4a-46f5-9f0b-0ee108a0ed7e/performance7.png)

Lambda 関数の Reserved Concurrency が 1 であれば、6 つのオブジェクトが同時にバケットに書き込まれたとしてもイベントは単一の実行環境によって順次処理され、保留中のイベントは内部キューに保持される。