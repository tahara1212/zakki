---
title: "microCMS APIのレートリミットとRetryによる遅延をSentryで検知・通知する"
category: "パフォーマンス最適化"
---

# microCMS APIのレートリミットとRetryによる遅延をSentryで検知・通知する

microCMS API を利用したアプリケーション開発において、データフェッチ処理はページの表示速度に直結する重要な要素です。しかし、APIにはレートリミットが存在し、短時間での過剰なリクエストは 429 Too Many Requests エラーを引き起こす可能性があります。microCMS の SDK は、この 429 エラーなどに対して自動的に retry 処理を行う機能を持っていますが、この retry の挙動が Sentry によるエラー監視を難しくする場合があります。

本記事では、microCMS API 利用時に発生するレートリミット起因の遅延を Sentry のパフォーマンスモニタリング機能を活用して検知し、通知を行う方法について、これまでのSentryサポートやmicroCMSサポートとのやり取りで得られた知見を基に詳述します。

## microCMS SDK の Retry 挙動について

microCMS サポートとのやり取りから判明した重要な点は、`microcms-js-sdk` を使用している場合、**retry 処理が完了するまでは 429 などのエラーは SDK 内部で隠蔽され、アプリケーションコードには返されない**という仕様です。

SDK は `async-retry` ライブラリを利用して、設定された回数（デフォルト最大2回）の再試行を自動的に行います。この retry の途中で 429 エラーが発生しても、SDK はそれを捕捉し、再リクエストを行います。Sentry は、アプリケーションコードでエラーが捕捉されるか、明示的に Sentry SDK のキャプチャ関数が呼ばれない限り、エラーを検知できません。

したがって、SDK が retry に成功した場合、Sentry には何も報告されません。Sentry がエラー（最終的な 429 や 5xx 系）を検知できるのは、**最大2回の retry がすべて失敗し、最終的に SDK から呼び出し元にエラーがスローされた場合のみ**となります。

この仕様により、「retry が発生した」というイベントそのものを、アプリケーションコードで捕捉したエラーとして Sentry で直接検知・通知することは、SDK をそのまま利用する限り困難です。

代替案としては、以下の方法が microCMS サポートから提示されています。

- SDK をフォークして `onRetry` フック内に Sentry 通知処理などを追加する。
- SDK を使用せず、fetch ベースで独自の retry 処理を実装し、Sentry 連携を組み込む。
- SDK の `console.log` 出力を利用し、Sentry Logs などと連携してログベースで retry を検知する。

しかし、コード変更や追加のシステム設定なしに Sentry 標準機能で対応するには、次で述べるパフォーマンスモニタリングによる遅延検知が最も現実的です。

## Sentry パフォーマンスモニタリングの基礎と Web Vitals

retry 発生そのものではなく、「retry によって処理時間が長くなった」という**遅延**を検知するアプローチが有効となります。ここで Sentry のパフォーマンスモニタリング機能が役立ちます。

Sentry のパフォーマンスモニタリングは、アプリケーションの操作を「**トランザクション**」と「**スパン**」として計測します。

- **トランザクション**: 一連の操作のまとまり（例: ページロード、API リクエスト全体）。1トランザクションにつき 1 Performance unit を消費します。
- **スパン**: トランザクションを構成する個々の操作（例: HTTP リクエスト、DB クエリ、関数呼び出しなど）。スパン単体では Performance unit を消費しません。

画像で確認した主な **SPAN.OP (Span Operation)** の種類は以下の通りです。

- `pageload`, `navigation`: ブラウザ側でのページロードやクライアントサイトルート遷移のトランザクション。
- `http.client`: アプリケーション（クライアントまたはサーバー）から外部への HTTP リクエスト。microCMS API コール、GA/Clarity への送信などがこれに該当します。
- `function.nextjs - getStaticProps (...)`: Next.js サーバーサイドでの `getStaticProps` 関数の実行。
- `browser - request`: ブラウザでの最初の HTML ドキュメントリクエスト（TTFB 関連）。
- `resource.img`, `resource.script`, `resource.css` など: ブラウザでのリソース読み込み。

### Web Vitals とパフォーマンス指標

Web Vitals は、Google が提唱する、**ユーザーが Web ページの体験をどのように感じているか**を測るための指標群です。Sentry のパフォーマンスモニタリングでも、これらの重要な指標を収集・表示できます。主な Web Vitals および関連指標は以下の通りです。

- **TTFB (Time to First Byte)**:
    - **定義**: ブラウザがサーバーにリクエストを送信してから、応答の最初のバイトを受信するまでの時間。
    - **意味**: サーバーがリクエストに対して応答を開始するまでの速さを示します。これが遅いと、ユーザーはコンテンツが表示されるまでの最初の待ち時間が長くなります。Sentry の `browser - request` スパンの Duration がこれに近い値を示します。
- **FCP (First Contentful Paint)**:
    - **定義**: ページの読み込みを開始してから、コンテンツ（テキスト、画像、非空白の canvas 要素など）の最初の部分がブラウザにレンダリングされるまでの時間。
    - **意味**: ユーザーが「何か表示された」と視覚的に認識できるまでの速さを示します。TTFB の後に発生し、初期の HTML や CSS の解析・描画に影響されます。Sentry の `pageload` や `navigation` トランザクションに関連付けられます。
- **LCP (Largest Contentful Paint)**:
    - **定義**: ページの読み込みを開始してから、ビューポート内で最も大きなコンテンツ要素（主要な画像、見出しなど）がレンダリングされるまでの時間。
    - **意味**: ユーザーが「ページの主要なコンテンツが表示された」と認識できるまでの速さを示します。Web Vitals の中でも特に重要な指標の一つで、ページのロード体験の中心的な部分を表します。Sentry の `pageload` や `navigation` トランザクションに関連付けられます。

画像で確認したように、`pageload`, `navigation`, `browser - request`, `measure - Next.js-before-hydration` といった、**ブラウザ側の初期ロードやレンダリングに関連するトランザクションやスパン**には、これらの Web Vitals の値（またはそれに準ずる計測値）が紐づけられて表示されます。これは、これらのスパンがユーザーがブラウザ上で体験するパフォーマンスに直接的に関連しているためです。

一方、`http.client` や `function.nextjs` のような個別の裏側操作を示すスパンは、Web Vitals の値に**影響を与える**要因となりますが、スパン自体が特定の Web Vitals のタイミングを示すわけではありません。例えば、遅い microCMS API の `http.client` スパンは、TTFB を遅延させ、結果として FCP や LCP を悪化させる可能性があります。

## Retry 起因の遅延を Sentry で検知するためのアラート設定

microCMS SDK の retry によって処理時間が長くなったことを検知し、通知を行うためには、Sentry のパフォーマンスアラートを設定します。目的は「microCMS API 関連の処理遅延」の検知です。

### 1. Define your metric

監視対象のメトリクスを定義します。

- **最初のドロップダウン (対象)**: `Spans` を選択します。
- **2番目のドロップダウン (集計)**: 遅延が大きい個々のリクエストを捉えるために、指定期間内の最大値を示す `max`、あるいは外れ値の影響を受けつつ全体的な遅延傾向を見る `p95` (`95th percentile`) が適切です。今回は `max` を選択するのが直接的です。
- **3番目のドロップダウン (メトリクス)**: スパンの処理時間を示す `span.duration` を選択します。
- **4番目のドロップダウン (時間間隔)**: 集計を行う時間間隔を設定します。retry 発生後比較的早く検知したい場合は、`5分 interval` や `10分 interval` のような短い間隔を選択します。24時間間隔では、瞬間的な遅延が見落とされる可能性があります。

### 2. Filter events - 検知対象の絞り込みが鍵

これが最も重要なステップです。ここで対象のスパンを正確に絞り込まないと、意図しない遅延（他のAPIコール、JS実行遅延など）によってアラートが発火し、ノイズが増えてしまいます。

`http.client` スパンは microCMS だけでなく、GA や Clarity など他のサービスへのリクエストも含まれます。

- **microCMS API への直接コール (`/api/v1/...`) に絞る場合:**
    - `span.type:http.client` AND `url:"https://sugojika.microcms.io/api/v1/"` (あるいは、より具体的なパスで絞り込み)

- **Next.js データルート (`/_next/data/...`) スパンを含めるか検討する場合:**
    - `/ _next/data/...` スパンは、Next.js サーバーサイドでのデータフェッチ結果をブラウザに返すリクエストです。このスパンの遅延は、その裏側で行われた microCMS などのデータ取得処理が遅かったことの結果として発生します。
    - これを監視対象に含めるかは、目的（microCMS API 自体の遅延 vs microCMS 連携起因でユーザー体験に影響する遅延）によります。含める場合は、URL フィルターに `/_next/data/` を含む条件を追加します。

- **ISR 環境における `function.nextjs` スパンの監視:**
    - ISR 環境では、`getStaticProps` が裏側で実行される際の遅延が重要です。ご自身のアプリケーションで `getStaticProps` 内でのリクエストがほぼ microCMS API に限定されている場合、`function.nextjs - getStaticProps` スパン全体の Duration を監視するのも有効なアプローチです。
    - `span.op:"function.nextjs"` AND `span.description:/getStaticProps/` (正規表現や部分一致で指定)
    - さらに、その中で実行された microCMS API コールに絞りたい場合は、`span.type:http.client` + microCMS URL 条件に加えて、`parent.span.op:"function.nextjs"` のような親子関係フィルターを追加できるか Sentry の UI で確認します。

推奨としては、まず **「`span.type:http.client` かつ microCMS API の `/api/v1/...` エンドポイントの URL を含む」** というフィルターで設定し、microCMS API への直接的な遅延を監視することから始めると良いでしょう。必要に応じて、`/ _next/data/...` や `function.nextjs` スパンを含むようにフィルターを調整します。

### 3. Set thresholds

アラートを発火させる閾値を設定します。

- `Static: above or below {x}` を選択します。
- `Critical` レベルで、集計メトリクス (`max(span.duration)`) が、retry による遅延時間（5〜10秒）を考慮した閾値 (`5000` ms や `8000` ms、`10000` ms など）を `Above`（上回る）条件を設定します。閾値は、retry 1回で発生しうる最小遅延（5秒）を基準にするか、より確実に複数回 retry が発生した場合（10秒程度）を基準にするかで調整します。

### 4. Set actions

アラート発火時の通知方法と通知先を設定します。

- `Critical Status` を選択し、通知したいツール（`Slack`, `Email`, `MS Teams` など）を選択します。
- 通知先の対象（`Member`, `Team` など）と具体的な通知先（チャンネル名、メンバー名など）を設定します。

### 解決済み閾値

問題が解消された際にアラート状態を「Resolved」（解決済み）に戻す条件です。

- `Below` を選択します。
- 値を指定します。多くの場合、**デフォルトの `Automatic` が推奨されます。** これは、Critical や注意で設定した閾値を下回った場合に自動的に解決済みと判断するという設定です。これにより、Critical 状態が解消された際に、自動的に解決済みの通知が送られます。

## ISR 環境における Sentry データの解釈の注意点

ISR を採用している場合、Sentry で計測されるサーバーサイドのパフォーマンスデータ（特に `function.nextjs - getStaticProps` スパンや、その中の microCMS API スパン）は、必ずしもユーザーがその瞬間に体感しているページの表示速度と**一致しない**ことがある点に注意が必要です。

ISR の revalidate 期間経過後の最初のリクエストでは、ユーザーにはキャッシュされた古いコンテンツが高速に表示されますが、その裏側で新しいデータのフェッチやページ再生成処理（Sentry で遅延として計測される部分）が実行されます。この遅延は、次に同じページにアクセスするユーザーの体験に影響します。

したがって、ISR 環境では、Sentry のパフォーマンスデータは「ユーザーが今見ているページの速度」だけでなく、「ユーザーが最新のコンテンツにアクセスするまでに時間がかかっている可能性」を示す指標としても解釈する必要があります。

## まとめ

microCMS SDK をそのまま利用する場合、retry の発生自体を Sentry でエラーとして直接検知することは困難です。しかし、Sentry のパフォーマンスモニタリングを活用し、microCMS API 関連の処理に絞ったスパンの Duration を監視することで、retry による遅延を効果的に検知し、通知を行うことが可能です。

特に、アラート設定における Filter events で対象のスパンを正確に絞り込むこと（`span.type:http.client` + microCMS URL、必要に応じて `function.nextjs` スパンなども含む）が重要です。ISR 環境では、サーバーサイドで実行される `getStaticProps` スパンやその中の microCMS API スパンの監視が、microCMS 連携起因のパフォーマンスボトルネック特定に有効です。

これらの設定を通じて、microCMS API 利用における潜在的な遅延（retry 発生の可能性を含む）を早期に発見し、ユーザー体験への影響を最小限に抑えるための改善活動に繋げることができます。
